using System.Text.Json.Serialization;
using zborek.Langfuse.Services;

namespace zborek.Langfuse.Models;

/// <summary>
///     Generation event body
/// </summary>
public class CreateGenerationEventBody : IDisposable
{
    [JsonIgnore]
    internal bool Scoped { get; set; }

    /// <summary>
    ///     Langfuse trace object
    /// </summary>
    [JsonIgnore]
    public LangfuseTrace? LangfuseTrace { get; init; }

    /// <summary>
    ///     Time provider
    /// </summary>
    [JsonIgnore]
    public TimeProvider TimeProvider { get; init; } = TimeProvider.System;

    /// <summary>
    ///     Trace id
    /// </summary>
    [JsonPropertyName("traceId")]
    public string? TraceId { get; set; }

    /// <summary>
    ///     /Identifier of the generation. Useful for sorting/filtering in the UI
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    ///     The time at which the generation started, defaults to the current time
    /// </summary>
    [JsonPropertyName("startTime")]
    public DateTime? StartTime { get; set; }

    /// <summary>
    ///     The time at which the generation ended
    /// </summary>
    [JsonPropertyName("endTime")]
    public DateTime? EndTime { get; set; }

    /// <summary>
    ///     The time at which the completion started (streaming). Set it to get latency analytics broken down into time until
    ///     completion started and completion duration
    /// </summary>
    [JsonPropertyName("completionStartTime")]
    public DateTime? CompletionStartTime { get; set; }

    /// <summary>
    ///     Additional metadata of the generation. Can be any JSON object. Metadata is merged when being updated via the API
    /// </summary>
    [JsonPropertyName("metadata")]
    public object? Metadata { get; set; }

    /// <summary>
    ///     The prompt used for the generation. Can be any string or JSON object
    /// </summary>
    [JsonPropertyName("input")]
    public object? Input { get; set; }

    /// <summary>
    ///     The completion generated by the model. Can be any string or JSON object
    /// </summary>
    [JsonPropertyName("output")]
    public object? Output { get; set; }

    /// <summary>
    ///     The level of the generation. Used for sorting/filtering of traces with elevated error levels and for highlighting
    ///     in the UI
    /// </summary>
    [JsonPropertyName("level")]
    public LangfuseLogLevel Level { get; set; } = LangfuseLogLevel.Default;

    /// <summary>
    ///     The status message of the generation. Additional field for context of the event. E.g. the error message of an error
    ///     event
    /// </summary>
    [JsonPropertyName("statusMessage")]
    public string? StatusMessage { get; set; }

    /// <summary>
    ///     Parent id
    /// </summary>
    [JsonPropertyName("parentObservationId")]
    public string? ParentObservationId { get; set; }

    /// <summary>
    ///     The version of the generation type. Used to understand how changes to the span type affect metrics. Useful in
    ///     debugging
    /// </summary>
    [JsonPropertyName("version")]
    public string? Version { get; set; }

    /// <summary>
    ///     Generation id
    /// </summary>
    [JsonPropertyName("id")]
    public string? Id { get; set; }

    /// <summary>
    ///     The name of the model used for the generation
    /// </summary>
    [JsonPropertyName("model")]
    public string? Model { get; set; }

    /// <summary>
    ///     The parameters of the model used for the generation; can be any key-value pairs
    /// </summary>
    [JsonPropertyName("modelParameters")]
    public object? ModelParameters { get; set; }

    /// <summary>
    ///     The usage object supports arbitrary usage types with their units of consumption. Refer to the docs on how to
    ///     automatically infer token usage and costs in Langfuse
    /// </summary>
    [JsonPropertyName("usage")]
    public object? Usage { get; private set; }

    /// <summary>
    ///     The cost object supports arbitrary cost types with their units of consumption. Refer to the docs on how to
    ///     automatically infer token usage and costs in Langfuse
    /// </summary>
    [JsonPropertyName("costDetails")]
    public object? CostDetails { get; set; }

    /// <summary>
    ///     Prompt name
    /// </summary>
    [JsonPropertyName("promptName")]
    public string? PromptName { get; set; }

    /// <summary>
    ///     Prompt version
    /// </summary>
    [JsonPropertyName("promptVersion")]
    public int? PromptVersion { get; set; }

    /// <summary>
    ///     Remove the last parent id from the trace
    /// </summary>
    public void Dispose()
    {
        if (Scoped)
        {
            LangfuseTrace?.RemoveLastParentId();
        }
    }

    /// <summary>
    ///     Set generation token usage
    /// </summary>
    /// <param name="usage">Usage object</param>
    public void SetUsage(object usage)
    {
        Usage = usage;
    }

    /// <summary>
    ///     Set generation output and end time
    /// </summary>
    /// <param name="output">Output from llm</param>
    public void SetOutput(object output)
    {
        Output = output;
        EndTime = TimeProvider.GetUtcNow().UtcDateTime;
    }
}

// TODO: change object? to specific types: https://api.reference.langfuse.com/#tag/ingestion